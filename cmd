#!/bin/bash
# shellcheck disable=SC2016
set -e
# export PATH="/bin:/usr/bin:/usr/local/bin" # safer, if you can

(( BASH_VERSINFO[0] < 4 )) && echo "Bash 4+ required." && exit 1

: "${PAGER:=more}"
: "${EDITOR:=vi}"
: "${HELP_BROWSER:=}"
: "${EXE:="${0##*/}"}"

declare -A HELP
declare -A CONFIG

HELP[main]='
# Bash Template Command

*This `README.md` is autogenerated.*

This is a GitHub template repo that will be copied instead of forked to
create a new Bash command with a command something like this:

```
gh repo create rwxrob/mycmd -p rwxrob/template-bash-command
```

This `cmd` inside can then be renamed and finished.

Obviously, not all of this is needed for many Bash scripts, but anything
with more than two subcommands will benefit from the builtin tab
completion, embedded Markdown help documentation support, and included
functions (`usage`, `_filter`, `_buffer`, `_have`, etc.)

## Naming Conventions

* Name repos containing single bash commands with `cmd-`
* Name template repos beginning with `template-`
* Start command functions with `command_` to be completed
* Start command functions with `command__` to not be completed

## Dependencies

Required:

* Bash 4+

Optional:

* `pandoc` - for rich help docs
* `jq` - for `json` and anything that uses it

## Justification

Bash is the dominate shell scripting language and the official default
Linux interactive shell, which reduces cognitive overhead; every command
line *is* a line of code that could be put into script as is. Bash
scripts are at the core of cloud, containers, and Kubernetes. Bash 4+
with its associative array support, powerful regular expressions, and
multiple ways of feeding data to loops easily covers the needs
previously requiring Python and Perl scripts. Bash scripts are also much
more powerful, safer, flexible, and performant than POSIX shell or Zsh.

## Guidelines

* Write GitHub Flavored Markdown only
* Use present tense ("outputs" over "will output")
* Prefer term "output" and "display" over ~~print~~
* Follow the [naming conventions](#naming-conventions) 
* Use the official bash path: `#!/bin/bash`
* Use of `#!/usr/bin/bash` is outdated
* Using `#!/usr/bin/env bash` introduces unnecessary risk
* Explicitly export `PATH` in script when possible
* Always check script with [`shellcheck`] before releasing
* Always use `bc` for *any* floating point math

[`shellcheck`]: <https://www.shellcheck.net>

## Legal

Copyright 2021 Rob Muhlestein <rob@rwx.gg>  
Released under Apache-2.0 License  
Please mention rwxrob.tv'

HELP[foo]='Foos things.'

command_foo() {
  _filter "$@" && return $?
  echo "would foo: $*"
}

HELP[bar]='

```
'"$EXE"' bar
```

Bar the things.'

command_bar() {
  _buffer "$@" && return $?
  echo "would bar: $*"
}
command__hidden() {
  _filter "$@" && return $?
  echo "would run _hidden: $*"
}

############################## BOILERPLATE ###########################
## Everything from here to the end of file can be snipped and updated
## with latest from https://github.com/rwxrob/template-bash-command.

# -------------------------- utility command -------------------------

HELP[usage]='Displays a summary of usage.'

command_usage() {
  local -a cmds
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:1} =~ _ ]] && continue
    cmds+=("$c")
  done
  local IFS='|'
  printf "usage: %s (%s)\n" "$EXE" "${cmds[*]}"
}

# --------------------------- help command ---------------------------

HELP[help]='

```
'"$EXE"' help [COMMAND]
```

Displays specific help information. If no argument is passed displays
general help information (main). Otherwise, the documentation for the
specific argument keyword is displayed, which usually corresponds to
a COMMAND name (but not necessarily). All documentation is written in
GitHub Flavored Markdown and will displayed as a web page if `pandoc`
and `$HELP_BROWSER` are detected, otherwise, just the Markdown is sent
to `$PAGER` (default: more).

Also see `readme` and `usage` commands.
'

command_help() { 
  local name="${1:-main}" title body
  title=$(_help_title "$name") || true
  if [[ -z "$title" ]]; then
    body="${HELP[$name]}"
    title="$EXE $name"
    [[ $name = main ]] && title="$EXE"
  else
    body="${HELP[$name]}"
    body=${body#*$title}
  fi
  local file="/tmp/help-$EXE-$name.html"
  if _have pandoc ; then
    if _have "$HELP_BROWSER" && [[ -t 1 ]] ;then
      pandoc -f gfm -s --metadata title="$title" \
        -o "$file" <<< "$body"
      [[ -z "$2" ]] && cd /tmp && exec "$HELP_BROWSER" "$file"
      return 0
    fi
    pandoc -f gfm -s --metadata title="$title" \
      -t plain <<< "$body" | "$PAGER"
    return 0
  fi
  echo -e "$title\n\n$body" | "$PAGER"
}

_help_title() {
  _filter "$@" && return $?;
  local name="$1"
  while IFS= read -r line; do
    [[ $line =~ ^[:space]*$ ]] && continue
    [[ $line =~ ^#\ (.+) ]] && echo "${BASH_REMATCH[1]}" && return 0
    return 1
  done <<< "${HELP[$name]}"
}

# -------------------------- readme command --------------------------

HELP[readme]='
## Generate `README.md` File

```
'"$EXE"' readme > README.md
```

The `readme` command will output the embedded help documentation in raw
GitHub Flavored Markdown suitable for use as a `README.md` file on
GitHub or similar hosting service.'

command_readme() {
  _trim "${HELP[main]}"
  echo
  while IFS= read -r name; do
    [[ $name = main ]] && continue
    body=$(_trim "${HELP[$name]}")
    [[ $body =~ ^\# ]] || body="## The \`$name\` Command"$'\n\n'$body
    printf "%s\n\n" "$body"
  done < <(printf "%s\n" "${!HELP[@]}" | LC_COLLATE=C sort)
  echo -e "----\n\n*Autogenerated $(date)*\n"
}

# -------------------------- config command --------------------------

HELP[config]='

```
'"$EXE"' config
'"$EXE"' config KEY
'"$EXE"' config KEY VALUE
'"$EXE"' config KEY ""
'"$EXE"' config dir
'"$EXE"' config path [file]
'"$EXE"' config edit [file]
```

The `config` command is for reading, writing, and displaying standard
open desktop configuration properties. Pass an empty string to delete
a property.

### Arguments

With no arguments outputs all the currently cached configuration
settings. 

With a single KEY argument fetches the value for that key and outputs
it unless it is one of the following special (reserved) key names:

* `dir` full path to config directory
* `path` full path to specific config file (default: `values`) 
* `edit` opens config file in editor (default: `editor` or `$EDITOR)

With more than one argument the remaining arguments after the KEY will
be combined into the VALUE and written to a `values` file in the
configuration directory. 

### Configuration Directory

The configuration directory path relies on the following environment
variables:

* `EXE` - defaults to name of currently running command ('"$EXE"')
* `HOME` - checked for `$HOME/.config/$EXE/values`
* `XDG_CONFIG_HOME` - overrides `$HOME/.config`
* `CONFIG_DIR` - full path to directory containing `values` file

The `CONFIG_DIR` always takes priority over anything else if set, but is
never implied. If the directory does not exist it will be created the
first time a value is set.

### Configuration `values` File Format

The file (which is almost always located at
`~/.config/'"$EXE"'/values`) uses the simplest possible format to
facilitate standard UNIX parsing and filtering with any number of
existing tools (and no `jq` dependency).

* One KEY=VALUE per line
* KEYs may be anything but the equal sign (`=`)
* VALUEs may be anything but line returns must be escaped

Note that this is *not* the same as Java properties and other similar
format. It is designed for ultimate simplicity, efficiency, and
portability.'

command_config() {
  case $1 in 
    dir)  _config_dir;  return $? ;;
    path) _config_path; return $? ;;
    edit) _config_edit; return $? ;;
  esac
  case $# in
    0) _config_dump ;; 
    1) _config_get "$@" ;;
    *) _config_set "$@" ;;
  esac
}

_config_edit() {
  : "${CONFIG[editor]:="${EDITOR:=vi}"}"
  exec "${CONFIG[editor]}" "$(_config_path "${1:-values}")"
}

_config_dir() {
  local dir="$HOME/.config/$EXE"
  [[ -n "$XDG_CONFIG_HOME" ]] && dir="$XDG_CONFIG_HOME/$EXE" 
  [[ -n "$CONFIG_DIR" ]] && dir="$CONFIG_DIR"
  [[ -n "$1" ]] && echo "$dir/$1" && return 0
  printf "%s" "$dir"
  [[ -t 1 ]] && echo
}

_config_path() { 
  local file=${1:-values}
  printf "%s/%s" "$(_config_dir)" "$file"
  [[ -t 1 ]] && echo
}

_config_set() {
  local key="$1"; shift; local val="$*"
  val="${val//$'\n'/\\n}"
  CONFIG["$key"]="$val"
  _config_write
}

_config_get() { 
  printf "${CONFIG[$1]}"
  [[ -t 1 ]] && echo
}

_config_read() {
  local values="$(_config_path)"
  [[ -r "$values" ]] || return 0
  while IFS= read -r line; do
    [[ $line =~ ^([^=]+)=(.+)$ ]] || continue
    CONFIG["${BASH_REMATCH[1]}"]="${BASH_REMATCH[2]}"
  done < "$values"
}

_config_write() {
  local dir="$(_config_dir)"
  mkdir -p "$dir"
  _config_dump > "$dir/values"
}

_config_dump() {
  (( ${#CONFIG[@]} == 0 )) && return 0
  paste -d=\
    <(printf "%s\n" "${!CONFIG[@]}") \
    <(printf "%s\n" "${CONFIG[@]}")
}

# --------------------------- json command ---------------------------

HELP[json]='
## Convert to JSON String

```
'"$EXE"' json STRING
'"$EXE"' json <<< STRING
'"$EXE"' json < FILE
'"$EXE"' json < <(COMMAND)
```

Converts input into JSON string using `jq` (if found) containing only
escaped (`\\n`) line returns.'

command_json() { _jsonstr "$@"; }

_jsonstr() {
  _buffer "$@" && return $?
  jq -MRsc <<< "$1"
}

# ----------------------------- utilities ----------------------------

_reduce() {
  local -n name="${1:?"name of array required"}"
  while IFS= read -r key; do
    [[ $key =~ $2 ]] && echo "$key"
  done < <(printf "%s\n" "${name[@]}")
}

_trim() {
  local it="${1#"${1%%[![:space:]]*}"}"
  echo -e "${it%"${it##*[![:space:]]}"}"
}

_have(){ type "$1" &>/dev/null; }

_filter(){
  [[ -n "$1" ]] && return 1
  while IFS= read -ra args; do
    "${FUNCNAME[1]}" "${args[@]}"
  done
}

_buffer() {
  [[ -n "$1" ]] && return 1
  "${FUNCNAME[1]}" "$(</dev/stdin)"
}

# --------------------- completion and delegation --------------------
#         (better than . <(foo bloated_completion) in .bashrc)

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ command_ ]] || continue
  COMMANDS+=( "${line##declare -f command_}" )
done < <(declare -F)
mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" && ${c:0:1} != _ ]] && echo "$c"
  done
  exit
fi

for c in "${COMMANDS[@]}"; do
  if [[ $c == "$EXE" ]]; then
    "command_$EXE" "$@"
    exit $?
  fi
done

_config_read

if [[ -n "$1" ]]; then
  declare cmd="$1"; shift
  for c in "${COMMANDS[@]}"; do
    if [[ $c == "$cmd" ]]; then
      "command_$cmd" "$@"
      exit $?
    fi
  done
fi

command_usage "$@"
